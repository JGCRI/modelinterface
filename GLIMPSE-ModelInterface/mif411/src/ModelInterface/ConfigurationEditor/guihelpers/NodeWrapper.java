/*
* LEGAL NOTICE
* This computer software was prepared by Battelle Memorial Institute,
* hereinafter the Contractor, under Contract No. DE-AC05-76RL0 1830
* with the Department of Energy (DOE). NEITHER THE GOVERNMENT NOR THE
* CONTRACTOR MAKES ANY WARRANTY, EXPRESS OR IMPLIED, OR ASSUMES ANY
* LIABILITY FOR THE USE OF THIS SOFTWARE. This notice including this
* sentence must appear on any copies of this computer software.
* 
* Copyright 2012 Battelle Memorial Institute.  All Rights Reserved.
* Distributed as open-source under the terms of the Educational Community 
* License version 2.0 (ECL 2.0). http://www.opensource.org/licenses/ecl2.php
* 
* EXPORT CONTROL
* User agrees that the Software will not be shipped, transferred or
* exported into any country or used in any manner prohibited by the
* United States Export Administration Act or any other applicable
* export laws, restrictions or regulations (collectively the "Export Laws").
* Export of the Software may require some form of license or other
* authority from the U.S. Government, and failure to obtain such
* export control license may result in criminal liability under
* U.S. laws. In addition, if the Software is identified as export controlled
* items under the Export Laws, User represents and warrants that User
* is not a citizen, or otherwise located within, an embargoed nation
* (including without limitation Iran, Syria, Sudan, Cuba, and North Korea)
*     and that User is not otherwise prohibited
* under the Export Laws from receiving the Software.
* 
*/
package ModelInterface.ConfigurationEditor.guihelpers;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

import org.w3c.dom.Node;

import ModelInterface.ConfigurationEditor.utils.DOMUtils;

/**
 * A class which wraps a DOM node and replaces the toString function with one
 * which returns the value of the name attribute. This class uses a proxy method
 * so that all function calls other than toString automatically are forwarded to
 * the underlying node.
 * 
 * @author Josh Lurz
 * 
 */
public class NodeWrapper implements InvocationHandler {

	/**
	 * Create an instance of this wrapper class with a node to wrap.
	 * 
	 * @param aNode
	 *            The node to wrap in this proxy class.
	 * @return An instance of the invocation handler.
	 */
	public static Object createProxy(final Node aNode) {
		return Proxy.newProxyInstance(aNode.getClass().getClassLoader(), aNode
				.getClass().getInterfaces(), new NodeWrapper(aNode));
	}

	/**
	 * The internal node which this class wraps.
	 */
	private final transient Node mInternalNode;

	/**
	 * Private constructor which sets the internal node to the one passed in.
	 * 
	 * @param aNodeToWrap
	 *            The node to forward all function calls to except toString.
	 */
	private NodeWrapper(Node aNodeToWrap) {
        super();
		mInternalNode = aNodeToWrap;
	}

	/**
	 * Method called when a function is invoked on the object. Checks if the
	 * function is the toString function and replaces it with a function that
	 * returns the value of the name attribute. Otherwise the call is forwarded
	 * to the internal node.
	 * 
	 * @param aProxy
	 *            The object on which the method is being invoked.
	 * @param aMethod
	 *            The method being invoked.
	 * @param aArgs
	 *            The arguments of the method being invoked.
	 * @return The return value of the requested method.
	 * @throws Throwable
	 *             Exception generated by the method.
	 */
	public Object invoke(final Object aProxy, final Method aMethod, final Object[] aArgs)
			throws Throwable {
		// Special case the toString method to return the value of the name
		// child.
		if (aMethod.getName().equals("toString")) { //$NON-NLS-1$
			return DOMUtils.getNameAttrValue(mInternalNode);
		}
		if (aMethod.getName().equals("equals")) {
			return aProxy == aArgs[0] ? Boolean.TRUE : Boolean.FALSE;
		}
		if (aMethod.getName().equals("hashCode")) {
			return new Integer(System.identityHashCode(aProxy));
		}
		// Dispatch all methods other than toString to the internal node object.
		Object result = null;
		try {
			result = aMethod.invoke(mInternalNode, aArgs);
		} catch (InvocationTargetException e) {
			throw e.getCause();
		}
		return result;
	}
}
